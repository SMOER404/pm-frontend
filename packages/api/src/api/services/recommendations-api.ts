/* tslint:disable */
/* eslint-disable */
/**
 * Poizon Market Recommendation System
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BatchRecommendationRequest } from '../models';
// @ts-ignore
import type { BatchRecommendationResponse } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { ProductMetricsResponse } from '../models';
// @ts-ignore
import type { ProductMetricsUpdate } from '../models';
// @ts-ignore
import type { RecommendationResponse } from '../models';
// @ts-ignore
import type { UserEventCreate } from '../models';
// @ts-ignore
import type { UserEventResponse } from '../models';
// @ts-ignore
import type { UserInteractionCreate } from '../models';
// @ts-ignore
import type { UserInteractionResponse } from '../models';
// @ts-ignore
import type { UserMetricsResponse } from '../models';
// @ts-ignore
import type { UserPreferencesCreate } from '../models';
// @ts-ignore
import type { UserPreferencesResponse } from '../models';
// @ts-ignore
import type { UserPreferencesUpdate } from '../models';
/**
 * RecommendationsApi - axios parameter creator
 * @export
 */
export const RecommendationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Создать взаимодействие пользователя с товаром
         * @param {UserInteractionCreate} userInteractionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInteraction: async (userInteractionCreate: UserInteractionCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInteractionCreate' is not null or undefined
            assertParamExists('createInteraction', 'userInteractionCreate', userInteractionCreate)
            const localVarPath = `/api/v1/recommendations/interactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInteractionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создать событие пользователя (альтернативный)
         * @param {UserEventCreate} userEventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserEventAlt: async (userEventCreate: UserEventCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userEventCreate' is not null or undefined
            assertParamExists('createUserEventAlt', 'userEventCreate', userEventCreate)
            const localVarPath = `/api/v1/recommendations/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEventCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение пакетных рекомендаций для нескольких пользователей
         * @summary Пакетные рекомендации для пользователей
         * @param {BatchRecommendationRequest} batchRecommendationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchRecommendations: async (batchRecommendationRequest: BatchRecommendationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchRecommendationRequest' is not null or undefined
            assertParamExists('getBatchRecommendations', 'batchRecommendationRequest', batchRecommendationRequest)
            const localVarPath = `/api/v1/recommendations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchRecommendationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение персонализированных рекомендаций
         * @summary Получить персональные рекомендации
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {boolean} [includeTrending] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalRecommendations: async (userId: string, limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, includeTrending?: boolean, minSimilarity?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getPersonalRecommendations', 'userId', userId)
            const localVarPath = `/api/v1/recommendations/personal/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (brand !== undefined) {
                localVarQueryParameter['brand'] = brand;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['min_price'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['max_price'] = maxPrice;
            }

            if (includeTrending !== undefined) {
                localVarQueryParameter['include_trending'] = includeTrending;
            }

            if (minSimilarity !== undefined) {
                localVarQueryParameter['min_similarity'] = minSimilarity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение популярных товаров
         * @summary Получить популярные товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minPopularity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularRecommendations: async (limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minPopularity?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/popular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (brand !== undefined) {
                localVarQueryParameter['brand'] = brand;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['min_price'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['max_price'] = maxPrice;
            }

            if (minPopularity !== undefined) {
                localVarQueryParameter['min_popularity'] = minPopularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение метрик товара
         * @summary Получить метрики товара
         * @param {string} productId ID товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductMetrics: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductMetrics', 'productId', productId)
            const localVarPath = `/api/v1/recommendations/metrics/product/{product_id}`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение похожих товаров
         * @summary Получить похожие товары
         * @param {string} itemId ID товара
         * @param {number} [limit] 
         * @param {string | null} [similarityType] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems: async (itemId: string, limit?: number, similarityType?: string | null, minSimilarity?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getSimilarItems', 'itemId', itemId)
            const localVarPath = `/api/v1/recommendations/similar/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (similarityType !== undefined) {
                localVarQueryParameter['similarity_type'] = similarityType;
            }

            if (minSimilarity !== undefined) {
                localVarQueryParameter['min_similarity'] = minSimilarity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение трендовых товаров
         * @summary Получить трендовые товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minTrending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingRecommendations: async (limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minTrending?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (brand !== undefined) {
                localVarQueryParameter['brand'] = brand;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['min_price'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['max_price'] = maxPrice;
            }

            if (minTrending !== undefined) {
                localVarQueryParameter['min_trending'] = minTrending;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение событий пользователя
         * @summary Получить события пользователя
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [eventType] 
         * @param {string | null} [startDate] 
         * @param {string | null} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEvents: async (userId: string, limit?: number, eventType?: string | null, startDate?: string | null, endDate?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserEvents', 'userId', userId)
            const localVarPath = `/api/v1/recommendations/events/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение метрик пользователя
         * @summary Получить метрики пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMetrics: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserMetrics', 'userId', userId)
            const localVarPath = `/api/v1/recommendations/metrics/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение предпочтений пользователя
         * @summary Получить предпочтения пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPreferences', 'userId', userId)
            const localVarPath = `/api/v1/recommendations/preferences/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Изменить предпочтения пользователя
         * @param {UserPreferencesUpdate} userPreferencesUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPreferences: async (userPreferencesUpdate: UserPreferencesUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPreferencesUpdate' is not null or undefined
            assertParamExists('putUserPreferences', 'userPreferencesUpdate', userPreferencesUpdate)
            const localVarPath = `/api/v1/recommendations/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPreferencesUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запуск очистки старых событий
         * @summary Запустить очистку старых событий
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerCleanupEvents: async (days?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/tasks/cleanup-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запуск обновления всех рекомендаций
         * @summary Запустить обновление всех рекомендаций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdateAllRecommendations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/tasks/update-all-recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запуск обновления популярных товаров
         * @summary Запустить обновление популярных товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdatePopularItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/tasks/update-popular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Запуск обновления трендовых товаров
         * @summary Запустить обновление трендовых товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdateTrendingItems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/recommendations/tasks/update-trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновить метрики товара
         * @param {string} productId ID товара
         * @param {ProductMetricsUpdate} productMetricsUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductMetrics: async (productId: string, productMetricsUpdate: ProductMetricsUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateProductMetrics', 'productId', productId)
            // verify required parameter 'productMetricsUpdate' is not null or undefined
            assertParamExists('updateProductMetrics', 'productMetricsUpdate', productMetricsUpdate)
            const localVarPath = `/api/v1/recommendations/products/{product_id}/metrics`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productMetricsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление предпочтений пользователя
         * @summary Обновить предпочтения пользователя
         * @param {UserPreferencesCreate} userPreferencesCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences: async (userPreferencesCreate: UserPreferencesCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPreferencesCreate' is not null or undefined
            assertParamExists('updateUserPreferences', 'userPreferencesCreate', userPreferencesCreate)
            const localVarPath = `/api/v1/recommendations/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPreferencesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecommendationsApi - functional programming interface
 * @export
 */
export const RecommendationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecommendationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Создать взаимодействие пользователя с товаром
         * @param {UserInteractionCreate} userInteractionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInteraction(userInteractionCreate: UserInteractionCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInteractionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInteraction(userInteractionCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.createInteraction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Создать событие пользователя (альтернативный)
         * @param {UserEventCreate} userEventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserEventAlt(userEventCreate: UserEventCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserEventAlt(userEventCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.createUserEventAlt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение пакетных рекомендаций для нескольких пользователей
         * @summary Пакетные рекомендации для пользователей
         * @param {BatchRecommendationRequest} batchRecommendationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchRecommendations(batchRecommendationRequest: BatchRecommendationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchRecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchRecommendations(batchRecommendationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getBatchRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение персонализированных рекомендаций
         * @summary Получить персональные рекомендации
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {boolean} [includeTrending] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonalRecommendations(userId: string, limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, includeTrending?: boolean, minSimilarity?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonalRecommendations(userId, limit, category, brand, minPrice, maxPrice, includeTrending, minSimilarity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getPersonalRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение популярных товаров
         * @summary Получить популярные товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minPopularity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopularRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minPopularity?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopularRecommendations(limit, category, brand, minPrice, maxPrice, minPopularity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getPopularRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение метрик товара
         * @summary Получить метрики товара
         * @param {string} productId ID товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductMetrics(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductMetrics(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getProductMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение похожих товаров
         * @summary Получить похожие товары
         * @param {string} itemId ID товара
         * @param {number} [limit] 
         * @param {string | null} [similarityType] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems(itemId: string, limit?: number, similarityType?: string | null, minSimilarity?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarItems(itemId, limit, similarityType, minSimilarity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getSimilarItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение трендовых товаров
         * @summary Получить трендовые товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minTrending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minTrending?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecommendationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingRecommendations(limit, category, brand, minPrice, maxPrice, minTrending, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getTrendingRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение событий пользователя
         * @summary Получить события пользователя
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [eventType] 
         * @param {string | null} [startDate] 
         * @param {string | null} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEvents(userId: string, limit?: number, eventType?: string | null, startDate?: string | null, endDate?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserEventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEvents(userId, limit, eventType, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getUserEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение метрик пользователя
         * @summary Получить метрики пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMetrics(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMetrics(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getUserMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение предпочтений пользователя
         * @summary Получить предпочтения пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPreferences(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferencesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPreferences(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.getUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Изменить предпочтения пользователя
         * @param {UserPreferencesUpdate} userPreferencesUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserPreferences(userPreferencesUpdate: UserPreferencesUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferencesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserPreferences(userPreferencesUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.putUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Запуск очистки старых событий
         * @summary Запустить очистку старых событий
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerCleanupEvents(days?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerCleanupEvents(days, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.triggerCleanupEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Запуск обновления всех рекомендаций
         * @summary Запустить обновление всех рекомендаций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerUpdateAllRecommendations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerUpdateAllRecommendations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.triggerUpdateAllRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Запуск обновления популярных товаров
         * @summary Запустить обновление популярных товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerUpdatePopularItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerUpdatePopularItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.triggerUpdatePopularItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Запуск обновления трендовых товаров
         * @summary Запустить обновление трендовых товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerUpdateTrendingItems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerUpdateTrendingItems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.triggerUpdateTrendingItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновить метрики товара
         * @param {string} productId ID товара
         * @param {ProductMetricsUpdate} productMetricsUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductMetrics(productId: string, productMetricsUpdate: ProductMetricsUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductMetrics(productId, productMetricsUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.updateProductMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление предпочтений пользователя
         * @summary Обновить предпочтения пользователя
         * @param {UserPreferencesCreate} userPreferencesCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPreferences(userPreferencesCreate: UserPreferencesCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferencesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPreferences(userPreferencesCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecommendationsApi.updateUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecommendationsApi - factory interface
 * @export
 */
export const RecommendationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecommendationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Создать взаимодействие пользователя с товаром
         * @param {UserInteractionCreate} userInteractionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInteraction(userInteractionCreate: UserInteractionCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserInteractionResponse> {
            return localVarFp.createInteraction(userInteractionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Создать событие пользователя (альтернативный)
         * @param {UserEventCreate} userEventCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserEventAlt(userEventCreate: UserEventCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserEventResponse> {
            return localVarFp.createUserEventAlt(userEventCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение пакетных рекомендаций для нескольких пользователей
         * @summary Пакетные рекомендации для пользователей
         * @param {BatchRecommendationRequest} batchRecommendationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchRecommendations(batchRecommendationRequest: BatchRecommendationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchRecommendationResponse> {
            return localVarFp.getBatchRecommendations(batchRecommendationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение персонализированных рекомендаций
         * @summary Получить персональные рекомендации
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {boolean} [includeTrending] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonalRecommendations(userId: string, limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, includeTrending?: boolean, minSimilarity?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<RecommendationResponse> {
            return localVarFp.getPersonalRecommendations(userId, limit, category, brand, minPrice, maxPrice, includeTrending, minSimilarity, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение популярных товаров
         * @summary Получить популярные товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minPopularity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopularRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minPopularity?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<RecommendationResponse> {
            return localVarFp.getPopularRecommendations(limit, category, brand, minPrice, maxPrice, minPopularity, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение метрик товара
         * @summary Получить метрики товара
         * @param {string} productId ID товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductMetrics(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductMetricsResponse> {
            return localVarFp.getProductMetrics(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение похожих товаров
         * @summary Получить похожие товары
         * @param {string} itemId ID товара
         * @param {number} [limit] 
         * @param {string | null} [similarityType] 
         * @param {number | null} [minSimilarity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems(itemId: string, limit?: number, similarityType?: string | null, minSimilarity?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<RecommendationResponse> {
            return localVarFp.getSimilarItems(itemId, limit, similarityType, minSimilarity, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение трендовых товаров
         * @summary Получить трендовые товары
         * @param {number} [limit] 
         * @param {string | null} [category] 
         * @param {string | null} [brand] 
         * @param {number | null} [minPrice] 
         * @param {number | null} [maxPrice] 
         * @param {number | null} [minTrending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minTrending?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<RecommendationResponse> {
            return localVarFp.getTrendingRecommendations(limit, category, brand, minPrice, maxPrice, minTrending, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение событий пользователя
         * @summary Получить события пользователя
         * @param {string} userId ID пользователя
         * @param {number} [limit] 
         * @param {string | null} [eventType] 
         * @param {string | null} [startDate] 
         * @param {string | null} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEvents(userId: string, limit?: number, eventType?: string | null, startDate?: string | null, endDate?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserEventResponse>> {
            return localVarFp.getUserEvents(userId, limit, eventType, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение метрик пользователя
         * @summary Получить метрики пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMetrics(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserMetricsResponse> {
            return localVarFp.getUserMetrics(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение предпочтений пользователя
         * @summary Получить предпочтения пользователя
         * @param {string} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserPreferencesResponse> {
            return localVarFp.getUserPreferences(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Изменить предпочтения пользователя
         * @param {UserPreferencesUpdate} userPreferencesUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserPreferences(userPreferencesUpdate: UserPreferencesUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserPreferencesResponse> {
            return localVarFp.putUserPreferences(userPreferencesUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Запуск очистки старых событий
         * @summary Запустить очистку старых событий
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerCleanupEvents(days?: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.triggerCleanupEvents(days, options).then((request) => request(axios, basePath));
        },
        /**
         * Запуск обновления всех рекомендаций
         * @summary Запустить обновление всех рекомендаций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdateAllRecommendations(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.triggerUpdateAllRecommendations(options).then((request) => request(axios, basePath));
        },
        /**
         * Запуск обновления популярных товаров
         * @summary Запустить обновление популярных товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdatePopularItems(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.triggerUpdatePopularItems(options).then((request) => request(axios, basePath));
        },
        /**
         * Запуск обновления трендовых товаров
         * @summary Запустить обновление трендовых товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerUpdateTrendingItems(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.triggerUpdateTrendingItems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновить метрики товара
         * @param {string} productId ID товара
         * @param {ProductMetricsUpdate} productMetricsUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductMetrics(productId: string, productMetricsUpdate: ProductMetricsUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ProductMetricsResponse> {
            return localVarFp.updateProductMetrics(productId, productMetricsUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление предпочтений пользователя
         * @summary Обновить предпочтения пользователя
         * @param {UserPreferencesCreate} userPreferencesCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences(userPreferencesCreate: UserPreferencesCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserPreferencesResponse> {
            return localVarFp.updateUserPreferences(userPreferencesCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecommendationsApi - object-oriented interface
 * @export
 * @class RecommendationsApi
 * @extends {BaseAPI}
 */
export class RecommendationsApi extends BaseAPI {
    /**
     * 
     * @summary Создать взаимодействие пользователя с товаром
     * @param {UserInteractionCreate} userInteractionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public createInteraction(userInteractionCreate: UserInteractionCreate, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).createInteraction(userInteractionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Создать событие пользователя (альтернативный)
     * @param {UserEventCreate} userEventCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public createUserEventAlt(userEventCreate: UserEventCreate, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).createUserEventAlt(userEventCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение пакетных рекомендаций для нескольких пользователей
     * @summary Пакетные рекомендации для пользователей
     * @param {BatchRecommendationRequest} batchRecommendationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getBatchRecommendations(batchRecommendationRequest: BatchRecommendationRequest, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getBatchRecommendations(batchRecommendationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение персонализированных рекомендаций
     * @summary Получить персональные рекомендации
     * @param {string} userId ID пользователя
     * @param {number} [limit] 
     * @param {string | null} [category] 
     * @param {string | null} [brand] 
     * @param {number | null} [minPrice] 
     * @param {number | null} [maxPrice] 
     * @param {boolean} [includeTrending] 
     * @param {number | null} [minSimilarity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getPersonalRecommendations(userId: string, limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, includeTrending?: boolean, minSimilarity?: number | null, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getPersonalRecommendations(userId, limit, category, brand, minPrice, maxPrice, includeTrending, minSimilarity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение популярных товаров
     * @summary Получить популярные товары
     * @param {number} [limit] 
     * @param {string | null} [category] 
     * @param {string | null} [brand] 
     * @param {number | null} [minPrice] 
     * @param {number | null} [maxPrice] 
     * @param {number | null} [minPopularity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getPopularRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minPopularity?: number | null, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getPopularRecommendations(limit, category, brand, minPrice, maxPrice, minPopularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение метрик товара
     * @summary Получить метрики товара
     * @param {string} productId ID товара
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getProductMetrics(productId: string, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getProductMetrics(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение похожих товаров
     * @summary Получить похожие товары
     * @param {string} itemId ID товара
     * @param {number} [limit] 
     * @param {string | null} [similarityType] 
     * @param {number | null} [minSimilarity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getSimilarItems(itemId: string, limit?: number, similarityType?: string | null, minSimilarity?: number | null, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getSimilarItems(itemId, limit, similarityType, minSimilarity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение трендовых товаров
     * @summary Получить трендовые товары
     * @param {number} [limit] 
     * @param {string | null} [category] 
     * @param {string | null} [brand] 
     * @param {number | null} [minPrice] 
     * @param {number | null} [maxPrice] 
     * @param {number | null} [minTrending] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getTrendingRecommendations(limit?: number, category?: string | null, brand?: string | null, minPrice?: number | null, maxPrice?: number | null, minTrending?: number | null, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getTrendingRecommendations(limit, category, brand, minPrice, maxPrice, minTrending, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение событий пользователя
     * @summary Получить события пользователя
     * @param {string} userId ID пользователя
     * @param {number} [limit] 
     * @param {string | null} [eventType] 
     * @param {string | null} [startDate] 
     * @param {string | null} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getUserEvents(userId: string, limit?: number, eventType?: string | null, startDate?: string | null, endDate?: string | null, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getUserEvents(userId, limit, eventType, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение метрик пользователя
     * @summary Получить метрики пользователя
     * @param {string} userId ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getUserMetrics(userId: string, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getUserMetrics(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение предпочтений пользователя
     * @summary Получить предпочтения пользователя
     * @param {string} userId ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public getUserPreferences(userId: string, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).getUserPreferences(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Изменить предпочтения пользователя
     * @param {UserPreferencesUpdate} userPreferencesUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public putUserPreferences(userPreferencesUpdate: UserPreferencesUpdate, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).putUserPreferences(userPreferencesUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Запуск очистки старых событий
     * @summary Запустить очистку старых событий
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public triggerCleanupEvents(days?: number, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).triggerCleanupEvents(days, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Запуск обновления всех рекомендаций
     * @summary Запустить обновление всех рекомендаций
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public triggerUpdateAllRecommendations(options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).triggerUpdateAllRecommendations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Запуск обновления популярных товаров
     * @summary Запустить обновление популярных товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public triggerUpdatePopularItems(options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).triggerUpdatePopularItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Запуск обновления трендовых товаров
     * @summary Запустить обновление трендовых товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public triggerUpdateTrendingItems(options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).triggerUpdateTrendingItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновить метрики товара
     * @param {string} productId ID товара
     * @param {ProductMetricsUpdate} productMetricsUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public updateProductMetrics(productId: string, productMetricsUpdate: ProductMetricsUpdate, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).updateProductMetrics(productId, productMetricsUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление предпочтений пользователя
     * @summary Обновить предпочтения пользователя
     * @param {UserPreferencesCreate} userPreferencesCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecommendationsApi
     */
    public updateUserPreferences(userPreferencesCreate: UserPreferencesCreate, options?: RawAxiosRequestConfig) {
        return RecommendationsApiFp(this.configuration).updateUserPreferences(userPreferencesCreate, options).then((request) => request(this.axios, this.basePath));
    }
}

